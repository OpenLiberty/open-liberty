/*******************************************************************************
 * Copyright (c) 2011, 2014 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package com.ibm.ws.artifact.zip.internal;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import com.ibm.websphere.ras.Tr;
import com.ibm.websphere.ras.TraceComponent;
import com.ibm.ws.artifact.zip.cache.ZipFileHandle;
import com.ibm.ws.ffdc.annotation.FFDCIgnore;
import com.ibm.wsspi.artifact.ArtifactContainer;
import com.ibm.wsspi.artifact.ArtifactEntry;
import com.ibm.wsspi.artifact.ArtifactNotifier;
import com.ibm.wsspi.kernel.service.utils.FileUtils;
import com.ibm.wsspi.kernel.service.utils.ParserUtils;
import com.ibm.wsspi.kernel.service.utils.PathUtils;

public class ZipFileContainer implements com.ibm.wsspi.artifact.ArtifactContainer {
    static final TraceComponent tc = Tr.register(ZipFileContainer.class);

    private final ContainerFactoryHolder containerFactoryHolder;
    private final ArtifactContainer parent;
    private final ArtifactEntry thisInParent;

    //map to hold locks for extraction blocking.
    private static final ConcurrentHashMap<String, CountDownLatch> cacheLocks = new ConcurrentHashMap<String, CountDownLatch>();

    //File holding the zip data for this zip container
    //if the zfc is based over a real zip file, this will be that file.
    //if the zfc is based over an inputstream of zip data, the data will be written out to the
    // cache dir, and this will be the file in the cache. 
    private File archiveFile;
    //Base folder to store inputstream data to avoid nested accesses.
    // nested zip inputstream data is placed here at an appropriate sub-path.
    // the sub-path strategy is explained in getNewCacheDirForEntry
    private final File cacheDir;
    //ZipFileHandle for the data, may be null until 1st access initializes it.
    private ZipFileHandle zipFileHandle;

    //always true, the sub containers in zips are of the type ZipFileDirNestedContainer
    private static final boolean isRoot = true;

    //map to store the paths found in the Zip, to ZipEntries representing them.
    private NavigableMap<String, ZipEntry> allEntries = null;

    // Per FindBugs:
    //
    // When deadlocks occur, the primary diagnosis tool used is the heap dump generated by a kill -3 signal.
    // All active locks are reported in this dump, but only by the class name and hash code of the actual code
    // (i.e., the class that allocated the object is not reported. Discovering what a particular lock is being
    // used to protect is significantly aided if you initialize the lock using an inner class rather than a
    // simple object.
    private class FastModeLock {};

    private final FastModeLock fastModeLock;
    private int fastModeCount;

    private final ArtifactNotifier artifactNotifier;

    /**
     * Root constructor, used when opening artifacts not part of a Container
     * 
     * @param cacheDir location for cache content for this zip
     * @param f The File to base this ZipFileContainer on.
     * @param c object to obtain the container factory from, when needed.
     */
    ZipFileContainer(File cacheDir, File f, ContainerFactoryHolder c) {
        this.cacheDir = cacheDir;
        this.archiveFile = f;
        this.parent = null;
        this.thisInParent = null;
        this.containerFactoryHolder = c;
        this.artifactNotifier = new ZipFileArtifactNotifier(this, c, f.getAbsolutePath());

        this.fastModeLock = new FastModeLock();
    }

    /**
     * Enclosed Zip File constructor, used when opening a File based zip enclosed by
     * another Container instance.
     * 
     * @param cacheDir location to store temporary content in for this zip.
     * @param parent
     * @param e
     * @param f The file representing the Zip archive, if one is available.. null if not.
     * @param c object to obtain the container factory from when required.
     */
    ZipFileContainer(File cacheDir, ArtifactContainer parent, ArtifactEntry e, File f, ContainerFactoryHolder c) {
        this.cacheDir = cacheDir;
        this.archiveFile = f;
        this.parent = parent;
        this.thisInParent = e;
        this.containerFactoryHolder = c;

        if (this.archiveFile != null) {
            this.artifactNotifier = new ZipFileArtifactNotifier(this, c, f.getAbsolutePath());
        } else {
            this.artifactNotifier = new ZipFileArtifactNotifier(this, c, e);
        }

        this.fastModeLock = new FastModeLock();
    }

    // Make sure to close the zip file quickly.
    @Override
    protected void finalize() throws Throwable {
        try {
            resetFastMode();
        } finally {
            super.finalize(); // throws Throwable
        }
    }

    /**
     * <p>Start using fast mode.
     * 
     * @see #useFastMode()
     */
    @Override
    public void useFastMode() {
        synchronized (fastModeLock) {
            fastModeCount++;
            //to keep things clean, if someone requests fast mode, 
            //and the file isnt open yet, we'll open it here.. 
            if (zipFileHandle == null) {
                //as we are entering fast mode, we configure the class var zipFileHandle to hold the 
                //single zfh we will use while fastmode is enabled.
                try {
                    zipFileHandle = getZipFileHandle();
                } catch (IOException e) {
                    //will be auto ffdc'd.
                }

                //go build the internal map & cache the zip data if needed.
                listEntries();
            }

            if (zipFileHandle != null) {
                //oddly, we don't need the returned ZipFile here, 
                //because all we want to do is cause the handle to remember there's still 
                //someone using the file..
                openZipHandle(zipFileHandle);
            }
        }
    }

    /**
     * <p>Stop using fast mode. That is, reduce the requests for fast
     * mode by one. Fast is only actually disabled when the fast mode
     * request count is reduced to zero.</p>
     * 
     * @see #stopUsingFastMode()
     */
    @Override
    public void stopUsingFastMode() {
        synchronized (fastModeLock) {
            if (fastModeCount > 0) {
                fastModeCount--;
                if (zipFileHandle != null) {
                    zipFileHandle.close();
                }
                //if we've left fast mode totally, then wipe our zip handle,
                //so we get a new one from the cache next time, that might already be in
                //fastmode for someone else ;p
                if (fastModeCount == 0) {
                    zipFileHandle = null;
                }
            }
        }
    }

    /**
     * <p>Reset fast mode: Force the fast mode count to zero, and close any current
     * fast mode zip file.</p>
     */
    protected void resetFastMode() {
        synchronized (fastModeLock) {
            if (zipFileHandle != null) {
                //call close on the zip file handle the same # as we called open.
                for (int i = 0; i < fastModeCount; i++) {
                    zipFileHandle.close();
                }
                fastModeCount = 0;
            }
            //safeguard against bad usage of this method in future.. (eg if zip file handle != null
            if (fastModeCount > 0) {
                throw new IllegalStateException();
            }
        }
    }

    //package protected method to obtain a cache dir for a given entry.
    //used by zipfileentry.
    File getNewCacheDirForEntry(ArtifactEntry e) {
        //every root container is given a cache dir when created.
        //the cachedir represents the folder that can be used to store content for that root container.

        //the cache directory is shared with all other containers sharing the same enclosing container. 

        //zip container uses this cache dir in this manner:
        //  cachedir/zipfilecontainer.jar        - file, used to hold the extracted bytes that represent the jar
        //                                         present when the zipfilecontainer would otherwise be a nested jar datastream
        //  cachedir/.cache                      - directory, shared by all containers with the same enclosing container as this one.
        //  cachedir/.cache/zipfilecontainer.jar - directory, used host the cache directories for nested archives within zipfilecontainer
        //                                         every nested archive within zipfilecontainer will have its own cache directory, present
        //                                         at a location equivalent to it's path within the zipfilecontainer

        File newCacheDir = new File(cacheDir, ".cache");

        //need to append the name of the root entry here.. if there is one.. 
        if (thisInParent != null) {
            //this zip container has a parent, and thus may have other zip containers to share the cachedir with. 
            //we use our zip containers entry name in the parent as a subdir under the cachedir to ensure we are good.
            newCacheDir = new File(newCacheDir, thisInParent.getName());
        } else {
            //there may be no 'thisInParent' if this zip has been opened directly as the very first container (the root of all roots)
            //
            //when this has happened, we use the .cache dir directly for nested archives, 
            //as there can be no other containers sharing its parent. (as it has none)
        }

        //newCacheDir is now the root for this container, add the path to the requested entries parent to it.
        String relativeLocation = e.getEnclosingContainer().getPath();
        if (!relativeLocation.equals("/")) {
            //use of substring 1 is ok here, because this zip entry MUST be within a container, and the smallest path
            //as container can have is "/", which is dealt with above, therefore, in this branch the relativeLocation MUST 
            //be longer than "/"
            newCacheDir = new File(newCacheDir, relativeLocation.substring(1));
        }

        return newCacheDir;
    }

    /**
     * Recursively remove a file/directory.
     * 
     * @param f
     * @return true if the delete succeeded, false otherwise
     */
    private boolean removeFile(File f) {
        if (FileUtils.fileIsFile(f)) {
            return Utils.delete(f);
        } else {
            //delete directory f..
            boolean ok = true;
            //remove all the children..
            File children[] = FileUtils.listFiles(f);
            if (children != null) {
                for (File child : children) {
                    ok &= removeFile(child);
                }
            }
            //once children are deleted, remove the directory
            if (ok) {
                ok &= Utils.delete(f);
            }
            return ok;
        }
    }

    /**
     * Extract the entry representing this archive to the cachedir.
     * 
     * @param e
     * @return
     * @throws IOException
     */
    File extractEntryToCacheFile(ArtifactEntry e) throws IOException {
        //validate the entry.. 
        InputStream i = null;
        try {
            i = e.getInputStream();
            if (i == null) {
                return null; //reject nonsense entries with no data & no container.
            } else {
                File dirForExtract = cacheDir;
                File targetOutputFile = new File(dirForExtract, e.getName());

                //we use a countdown latch in the map keyed by canonical path.
                //1st person to add will win via putifAbsent, all others will lose
                //and obtain a reference to the countdown latch added, that they can
                //then wait on. 
                //The wait will only happen the 1st init for any given zip container
                //instance.. so should only hold up for as long as it takes to write out
                //the file on the original thread.
                String lockKey = targetOutputFile.getCanonicalPath();
                boolean creator = false;
                CountDownLatch c = new CountDownLatch(1);
                CountDownLatch creatorLatch = c;
                c = ZipFileContainer.cacheLocks.putIfAbsent(lockKey, c);
                if (c != null) {
                    try {
                        //there was a latch stored.. wait until it counts down.. 
                        c.await(60, TimeUnit.SECONDS);
                    } catch (InterruptedException e1) {
                        //proceed if interrupted.. 
                    }
                } else {
                    creator = true;
                    c = creatorLatch;
                }
                creatorLatch = null;
                //                System.out.println("Creating temp file for " + e.getPath() + " for zip impl"
                //                                   + "\n - dirForExtract:" + dirForExtract.getAbsolutePath()
                //                                   + "\n - targetOutputFile:" + targetOutputFile.getAbsolutePath()
                //                                   + "\n - exists?:" + targetOutputFile.exists()
                //                                   + "\n - isFile?:" + targetOutputFile.isFile()
                //                                   + "\n - e.lastModifed:" + e.getLastModified()
                //                                   + "\n - target.lastModified:" + targetOutputFile.lastModified()
                //                                   + "\n - dirForExtract.exists?:" + dirForExtract.exists()
                //                                   );

                if (FileUtils.fileExists(targetOutputFile)) {
                    if (FileUtils.fileIsFile(targetOutputFile)) {
                        //need to consider when/how to update output.
                        long targetLastModified = FileUtils.fileLastModified(targetOutputFile);
                        long entryLastModified = e.getLastModified();
                        //set can only guarantee operation to within 1second. 
                        //so we check here that the diff in milliseconds is within just over a second.. 
                        if (Math.abs(targetLastModified - entryLastModified) < 1010L) {
                            if (creator) {
                                c.countDown();
                                ZipFileContainer.cacheLocks.remove(lockKey);
                            }
                            return targetOutputFile;
                        } else {
                            //System.out.println("cache file exists but has incorrect last modified");
                        }
                    } else if (FileUtils.fileIsDirectory(targetOutputFile)) {
                        //file exists, and is a directory? some sort of previous expansion must have 
                        //taken place that has damaged our content. this could occur if the user has changed
                        //the app content structure.

                        //we'll try to handle this by removing the unexpected cache content.
                        removeFile(targetOutputFile);

                        Tr.warning(tc, "remove.cache.data", targetOutputFile.getAbsolutePath());
                    }
                }

                if (!FileUtils.ensureDirExists(dirForExtract)) {
                    if (creator) {
                        c.countDown();
                        ZipFileContainer.cacheLocks.remove(lockKey);
                    }
                    return null;
                }

                File f = targetOutputFile;
                FileOutputStream fos = null;
                try {
                    //set false to overwrite if its already there..
                    fos = Utils.getOutputStream(f, false);

                    //wrap it up in an attempt to ensure it's got some buffering.
                    i = new BufferedInputStream(i);

                    //rip out the data & spew it to the file.
                    byte buf[] = new byte[1024];
                    int len;
                    while ((len = i.read(buf)) > 0) {
                        fos.write(buf, 0, len);
                    }
                    fos.close();
                    fos = null;

                    //guaranteed to set the value to within 1000ms of the requested. 
                    if (!Utils.setLastModified(f, e.getLastModified())) {
                        //Log failure to sync the last modified timestamp. 
                        //side effects will be increased i/o when file gets re-extracted for no reason.
                    }

                    return f;
                } finally {
                    if (creator) {
                        c.countDown();
                        ZipFileContainer.cacheLocks.remove(lockKey);
                    }
                    if (fos != null) {
                        fos.close();
                    }
                }
            }
        } finally {
            if (i != null) {
                try {
                    i.close();
                } catch (IOException e1) {
                }
            }
        }
    }

    private void setupArchiveFile() {
        //easy case, we were based on a file already.
        if (archiveFile != null)
            return;

        //we have no archive file.. means we came in from an Entry, and are expected to 
        //use the inputStream from the Entry.. for performance, we extract that out to 
        //our cache dir, and use it from there.
        try {
            archiveFile = extractEntryToCacheFile(thisInParent);
        } catch (IOException io) {
            Tr.error(tc, "extract.cache.fail", io.getMessage());
        }
    }

    /**
     * Build the map of all entries within this ZipFileContainer.
     * <p>
     * The map will <em>Only</em> hold the entries within the underlying Zip,
     * entries within the zip within directories not in the zip, will not have
     * those directories within this map.<p>
     * Paths are normalised from their zip equivalents to remove trailing /'s
     * and add a leading / where required.<p>
     * Visibility package, so this method can be invoked from the Notifier.
     * 
     * @return Map of path, to ZipEntry
     */
    NavigableMap<String, ZipEntry> listEntries() {
        //only ever build the list once.. 
        if (this.allEntries != null)
            return this.allEntries;

        NavigableMap<String, ZipEntry> zeMap = new TreeMap<String, ZipEntry>(PathUtils.PATH_COMPARATOR);

        setupArchiveFile();
        //if archiveFile is still null, we return empty map..
        if (archiveFile != null) {
            populateListFromZipArchive(zeMap);
        }

        //stash the result for future usage..
        this.allEntries = zeMap;

        return zeMap;
    }

    private ZipFile openZipHandle(ZipFileHandle zfh) {
        try {
            return zfh.open();
        } catch (IOException e) {
            // Oops: The ZipFile is corrupt, or inaccessible, or missing, or has a non-valid path.
            zipFileHandle = null;
            Tr.error(tc, "bad.zip.data", archiveFile.getAbsolutePath());
        }
        return null;
    }

    //will NOT return null.
    @FFDCIgnore(PrivilegedActionException.class)
    synchronized ZipFileHandle getZipFileHandle() throws IOException {

        if (zipFileHandle != null) {
            return zipFileHandle;
        }

        if (archiveFile == null) {
            setupArchiveFile();
        }

        if (archiveFile != null) {
            String path = archiveFile.getAbsolutePath();
            try {
                if (System.getSecurityManager() == null) {
                    path = archiveFile.getCanonicalPath();

                } else {
                    final File f_archiveFile = archiveFile;
                    try {
                        path = AccessController.doPrivileged(new PrivilegedExceptionAction<String>() {
                            @Override
                            public String run() throws IOException {
                                return f_archiveFile.getCanonicalPath();
                            }
                        });
                    } catch (PrivilegedActionException e) {
                        throw (IOException) e.getException();
                    }

                }
            } catch (IOException io) {
                //fallback to using abs path, means the caching will be less effective..
                if (tc.isDebugEnabled())
                    Tr.debug(tc, "Unable to resolve canonical path for " + path, archiveFile);
            }

            //will not return null, will IOException on error.
            ZipFileHandle zfh = containerFactoryHolder.getZipCachingService().openZipFile(path);
            return zfh;
        } else {
            //we can be here if archiveFile is still null after the setupArchiveFile
            //in which case we must have been a nested stream that failed to extract
            //and there will be a Tr.error already output, so here we just report it as an FNF.
            throw new FileNotFoundException(thisInParent.getPath());
        }
    }

    /**
     * Generate the entry map from the zip data
     * Call once this.archiveFile is non-null.
     * 
     * @param zeMap
     */
    private void populateListFromZipArchive(NavigableMap<String, ZipEntry> zeMap) {
        try {
            ZipFileHandle zfh = getZipFileHandle(); //will not return null.

            ZipFile useZipFile = openZipHandle(zfh);
            if (useZipFile != null) {
                try {
                    Enumeration<? extends ZipEntry> entryEnum = useZipFile.entries();
                    while (entryEnum.hasMoreElements()) {
                        ZipEntry ze = entryEnum.nextElement();
                        String zeName = ze.getName();

                        // Normalize the name: remove any trailing slash.
                        if (ze.isDirectory()) { // "ze.isDirectory()" is equivalent to "zeName.endsWith('/')".
                            zeName = zeName.substring(0, zeName.length() - 1);
                        }

                        zeMap.put(zeName, ze);
                    }

                } finally {
                    //always close zip handle after opening.. 
                    //fastmode is now implemented as 'extra' open requests to the handle, holding it open.
                    zfh.close(); // throws IOException
                }
            }

        } catch (IllegalStateException e) {
            // means someone tried to build this zip entry after the main zip file container factory was
            // deactivated.. server is shutting down.. do not process zip.
            zipFileHandle = null;
        } catch (IOException e) {
            zipFileHandle = null;
            //UNABLE TO OBTAIN ZIP FILE HANDLE FROM ZIP FILE CACHING SERVICE
            //will be auto ffdc'd.
        }
    }

    @Override
    public Iterator<ArtifactEntry> iterator() {
        //TODO: ask djv re thread safety.
        if (this.allEntries == null) {
            this.allEntries = listEntries();
        }
        return new ZipFileEntryIterator(this, this, archiveFile, this.allEntries, getPath(), containerFactoryHolder);
    }

    @Override
    public ArtifactContainer getEnclosingContainer() {
        return parent;
    }

    @Override
    public ArtifactEntry getEntryInEnclosingContainer() {
        return thisInParent;
    }

    @Override
    public String getPath() {
        //ZipFileContainer will always have a path of / because it is a root container.
        return "/";
    }

    @Override
    public String getName() {
        return "/";
    }

    @Override
    public ArtifactEntry getEntry(String pathAndName) {
        return getEntry(pathAndName, false);
    }

    public ArtifactEntry getEntry(String pathAndName, boolean normalized) {
        //quick test..  TODO: ask djv re threading.
        if (this.allEntries == null) {
            this.allEntries = listEntries();
        }

        if (pathAndName.equals("/") || pathAndName.equals("")) {
            return null;
        }

        //remove trailing /'s 
        if (pathAndName.endsWith("/")) {
            pathAndName = pathAndName.substring(0, pathAndName.length() - 1);
        }

        String absolutePathAndName = pathAndName;

        //remove leading /'s 
        if (pathAndName.startsWith("/")) {
            pathAndName = pathAndName.substring(1);
        }

        ZipEntry zipEntry = this.allEntries.get(pathAndName);
        if (zipEntry == null) {
            if (!normalized) {
                pathAndName = PathUtils.normalizeUnixStylePath(absolutePathAndName);
                normalized = true;
            }
            //check the path is not trying to go upwards.
            if (!PathUtils.isNormalizedPathAbsolute(pathAndName)) {
                return null;
            }

            if (pathAndName.equals("/") || pathAndName.equals("")) {
                return null;
            }

            absolutePathAndName = pathAndName;

            //remove leading /'s 
            if (pathAndName.startsWith("/")) {
                pathAndName = pathAndName.substring(1);
            }

            //path may exist, or not, if not, path may be a super path of one that does exist.

            //Validate if the pathAndName has a corresponding ZipEntry, either matching it exactly,
            //or existing for a path that would be below pathAndName in the hierarchy.
            zipEntry = this.allEntries.get(pathAndName);
        }

        boolean found = zipEntry != null;
        if (zipEntry == null) {
            String higherKey = this.allEntries.higherKey(pathAndName);
            found = higherKey != null &&
                    higherKey.startsWith(pathAndName) &&
                    higherKey.length() > pathAndName.length() &&
                    higherKey.charAt(pathAndName.length()) == '/';
        }

        if (found) {
            //zip does contain path.. (or a child of path)
            String name = PathUtils.getName(pathAndName);
            if (!!!absolutePathAndName.startsWith("/")) {
                absolutePathAndName = '/' + absolutePathAndName;
            }

            ZipFileEntry ze = new ZipFileEntry(this, zipEntry, name, absolutePathAndName, archiveFile, this.allEntries, containerFactoryHolder);
            return ze;

        }

        //path requested was neither in the zip, nor a superpath of an entry in the zip.
        return null;
    }

    /** {@inheritDoc} */
    @Override
    public ArtifactContainer getRoot() {
        return this;
    }

    /** {@inheritDoc} */
    @Override
    public Collection<URL> getURLs() {
        // We are either a single zip file or a zip within a zip and loaded the contents via an input stream        
        setupArchiveFile();
        if (this.archiveFile != null) {
            //this.archiveFile is either a jar in an expanded app, or is a jar we extracted to cache
            //we extract ALL jars that were nested, so for all zip containers this will work, 
            //(except those where the cache failed to extract, or bad jars, or io/exceptions etc..)
            try {
                URL zipUrl = archiveFile.toURI().toURL();
                return Collections.singleton(zipUrl);
            } catch (MalformedURLException e) {
            }

            //this uri should always end up file:/ as the zip container extracts nested zips out to cache
        }

        return Collections.emptySet();
    }

    /**
     * <p>
     * Constructs a URI for the given entry using the syntax:
     * </p>
     * <code>wsjar:&lt;archiveUri&gt;!/&lt;entryPath&gt;</code>
     * 
     * @param path The path to the entry to get a URI for
     * @param jarFile The file representing the JAR that the entry is contained in
     * @return
     */
    URI createEntryUri(final String path, final File jarFile) {
        // toURI requires Java 2 permissions
        URI zipUri = AccessController.doPrivileged(new PrivilegedAction<URI>() {

            @Override
            public URI run() {
                String updatedPath = path;
                if (updatedPath.startsWith("/") && updatedPath.length() > 1) {
                    updatedPath = updatedPath.substring(1);
                } else {
                    updatedPath = "";
                }
                URI parentUri = jarFile.toURI();
                if (parentUri != null) {

                    //URLs for jar/zip data now use wsjar to avoid locking issues via jar: protocol.
                    //Note, it is preferred to use the URI constructor that takes a single string so
                    // that we can control the encoding and decoding - also note that the call to
                    // parentUri.toString() will return an encoded string - so we must decode that
                    // string in WSJarURLStreamHandler.
                    //More info here: http://stackoverflow.com/questions/9419658/normalising-possibly-encoded-uri-strings-in-java.
                    String uriString = getProtocol() + ":" + parentUri.toString() + "!/" + ParserUtils.encode(updatedPath);
                    try {
                        return new URI(uriString);
                    } catch (URISyntaxException e) {
                        // Ignore
                    }
                }
                return null;
            }
        });

        return zipUri;
    }

    /**
     * @return
     */
    private String getProtocol() {
        if (containerFactoryHolder.useJarUrls()) {
            return "jar";
        } else {
            return "wsjar";

        }
    }

    /** {@inheritDoc} */
    @Override
    public String getPhysicalPath() {
        if (archiveFile != null) {
            return archiveFile.getAbsolutePath();
        } else {
            //we may gain a physical path when we cache the zip.. 
            if (this.allEntries == null) {
                this.allEntries = listEntries();
            }
            if (archiveFile != null) {
                return archiveFile.getAbsolutePath();
            }
        }
        return null;
    }

    //package protected method to obtain the cachedir for this archive
    File getCacheDir() {
        return cacheDir;
    }

    /** {@inheritDoc} */
    @Override
    public ArtifactNotifier getArtifactNotifier() {
        return this.artifactNotifier;
    }

    @Override
    public boolean isRoot() {
        //always true for the ZipFileContainer, nested dirs are represented as a different class
        //ZipFileNestedDirContainer.
        return true;
    }
}
