/*
 * Copyright 2017 VMware, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.openliberty.microprofile.metrics30.internal.micrometer;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.TreeSet;

/**
 * Generator for a set of histogram buckets intended for use by a monitoring system that
 * supports aggregable percentile approximations such as Prometheus'
 * {@code histogram_quantiles} or Atlas' {@code :percentiles}.
 */
public class PercentileHistogramBuckets {

    // Number of positions of base-2 digits to shift when iterating over the long space.
    private static final int DIGITS = 2;

    // Bucket values to use, see static block for initialization.
    private static final NavigableSet<Double> PERCENTILE_BUCKETS;

    // The set of buckets is generated by using powers of 4 and incrementing by one-third
    // of the previous power of 4 in between as long as the value is less than the next
    // power of 4 minus the delta.
    //
    // <pre>
    // Base: 1, 2, 3
    //
    // 4 (4^1), delta = 1
    // 5, 6, 7, ..., 14,
    //
    // 16 (4^2), delta = 5
    // 21, 26, 31, ..., 56,
    //
    // 64 (4^3), delta = 21
    // ...
    // </pre>
    static {
        PERCENTILE_BUCKETS = new TreeSet<>();
        PERCENTILE_BUCKETS.add(1.0);
        PERCENTILE_BUCKETS.add(2.0);
        PERCENTILE_BUCKETS.add(3.0);

        int exp = DIGITS;
        while (exp < 64) {
            long current = 1L << exp;
            long delta = current / 3;
            long next = (current << DIGITS) - delta;

            while (current < next) {
                PERCENTILE_BUCKETS.add((double) current);
                current += delta;
            }
            exp += DIGITS;
        }
        PERCENTILE_BUCKETS.add(Double.POSITIVE_INFINITY);
    }

    /**
     * Pick values from a static set of percentile buckets that yields a decent error
     * bound on most real world timers and distribution summaries because monitoring
     * systems like Prometheus require us to report the same buckets at every interval,
     * regardless of where actual samples have been observed.
     *
     * @param distributionStatisticConfig A configuration the governs how many buckets to
     *                                        produce based on its minimum and maximum expected values..
     * @return The set of histogram buckets for use in computing aggregable percentiles.
     */
    public static NavigableSet<Double> buckets(double minimumBucket, double maximumBucket) {
        // System.out.println("BUCKET SIZE EARLY: " + PERCENTILE_BUCKETS.subSet(minimumBucket, false,
        // maximumBucket, false).size());
        return PERCENTILE_BUCKETS.subSet(minimumBucket, true, maximumBucket, true);
        //return PERCENTILE_BUCKETS;
    }

    public static NavigableSet<Double> getDefaultBuckets(double minimumBucket, double maximumBucket, boolean isTimer) {
        NavigableSet<Double> defaultBuckets = new TreeSet<>();

        if (isTimer) {
            Iterator<Double> itr = buckets(0.00, Double.MAX_VALUE).iterator();

            while (itr.hasNext()) {
                //double test = itr.next() / 1000000000.0;
                double nextValue = itr.next();
                // System.out.println("Value: " + nextValue);
                BigDecimal decimalValue = new BigDecimal(nextValue / 1000000000.0);
                decimalValue = decimalValue.setScale(9, RoundingMode.HALF_UP).stripTrailingZeros();

                BigDecimal minValue = minimumBucket >= 0.001 ? new BigDecimal(minimumBucket) : new BigDecimal(0.001);
                BigDecimal maxValue = maximumBucket <= 30 ? new BigDecimal(maximumBucket) : new BigDecimal(30);

                if (decimalValue.compareTo(maxValue) < 0 && decimalValue.compareTo(minValue) > 0) {
                    defaultBuckets.add(decimalValue.doubleValue());
                }

            }

            System.out.println("timer default added: " + defaultBuckets);
            if (!defaultBuckets.contains(minimumBucket) && minimumBucket >= 0.001) {
                BigDecimal minBucketValue = new BigDecimal(minimumBucket).setScale(9, RoundingMode.HALF_UP).stripTrailingZeros();
                defaultBuckets.add(minBucketValue.doubleValue());
                System.out.println("Adding min here? -- " + minimumBucket);
            } else {
                System.out.println("Not adding! min bucket: " + minimumBucket);
            }
            if (!defaultBuckets.contains(maximumBucket) && maximumBucket <= 30) {
                BigDecimal maxBucketValue = new BigDecimal(maximumBucket).setScale(9, RoundingMode.HALF_UP).stripTrailingZeros();;
                defaultBuckets.add(maxBucketValue.doubleValue());
            }

        } else {
            // try {
            Double minValue = minimumBucket >= 1 ? minimumBucket : 1;
            Double maxValue = maximumBucket <= Double.MAX_VALUE ? maximumBucket : Double.MAX_VALUE;
            System.out.println("Min/max: " + minValue + " -- " + maxValue);
            NavigableSet<Double> originalBuckets = buckets(minValue, maxValue);
            defaultBuckets.addAll(originalBuckets);

            if (!defaultBuckets.contains(minimumBucket)) {
                BigDecimal minBucketValue = new BigDecimal(minimumBucket).setScale(9, RoundingMode.HALF_UP).stripTrailingZeros();
                defaultBuckets.add(minBucketValue.doubleValue());
            }
            if (!defaultBuckets.contains(maximumBucket)) {
                BigDecimal maxBucketValue = new BigDecimal(maximumBucket).setScale(9, RoundingMode.HALF_UP).stripTrailingZeros();;
                defaultBuckets.add(maxBucketValue.doubleValue());
            }
//            } catch(Exception e) {
//                System.out.println("EXCEPTION HERE!: " + e.getMessage());
//            }

        }

        System.out.println("IN HERE---5");
        System.out.println(defaultBuckets);
        return defaultBuckets;
    }

    public static void main(String args[]) {
        NavigableSet<Double> test = getDefaultBuckets(1, 30, false);
        System.out.println(test.size() + " -- " + test);
        //test.add(0.003495251);
        //System.out.println(test);

//        System.out.println(Double.POSITIVE_INFINITY / 1000000000.0);
//        System.out.println("size: " + buckets(0.00, Double.MAX_VALUE).size());
//
//        //Iterator<Double> itr = buckets(0.01, 28.633115306).iterator();
//        Iterator<Double> itr = buckets(0.00, Double.MAX_VALUE).iterator();
//        while (itr.hasNext()) {
//            //double test = itr.next() / 1000000000.0;
//            double nextValue = itr.next();
//            // System.out.println("Value: " + nextValue);
//            BigDecimal decimalValue = new BigDecimal(nextValue / 1000000000.0);
//            decimalValue = decimalValue.round(new java.math.MathContext(10)).stripTrailingZeros();
//            BigDecimal maxValue = new BigDecimal(10.0);
//            BigDecimal minValue = new BigDecimal(0.001);
//
//            int compareResult = decimalValue.compareTo(maxValue);
//
//            if (decimalValue.compareTo(maxValue) < 0 && decimalValue.compareTo(minValue) > 0) {
//
//                //double test = itr.next();
//                System.out.println(decimalValue);
//            } else {
//                // System.out.println("Not in subset");
//            }
//
//        }
    }

}