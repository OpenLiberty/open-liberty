/*******************************************************************************
 * Copyright (c) 2019, 2021 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

package com.ibm.ws.security.acme.fat;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

import com.ibm.websphere.simplicity.log.Log;
import com.ibm.ws.security.acme.AcmeCaException;
import com.ibm.ws.security.acme.AcmeCertificate;
import com.ibm.ws.security.acme.docker.CAContainer;
import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;
import com.ibm.ws.security.acme.internal.AcmeClient;
import com.ibm.ws.security.acme.internal.AcmeConfig;
import com.ibm.ws.security.acme.internal.util.AcmeConstants;
import com.ibm.ws.security.acme.utils.AcmeFatUtils;
import com.ibm.ws.security.acme.utils.HttpChallengeServer;

import componenttest.annotation.SkipForRepeat;
import componenttest.custom.junit.runner.FATRunner;

/**
 * Unit tests for the {@link AcmeClient} class. These tests are limited to those
 * that do not interact with an ACME CA service.
 */
@RunWith(FATRunner.class)
@SkipForRepeat(SkipForRepeat.EE9_FEATURES) // No value added
public class AcmeClientTest {

	private static final String TEST_DOMAIN_1 = "domain1.com";
	private static final String TEST_DOMAIN_2 = "domain2.com";
	private static final String TEST_DOMAIN_3 = "domain3.com";
	private static final String TEST_DOMAIN_4 = "domain4.com";

	private static HttpChallengeServer challengeServer = null;

	private static String TRUSTSTORE_FILE;
	private static String FILE_ACCOUNT_KEY;
	private static String FILE_DOMAIN_KEY;
	private static final String TRUSTSTORE_PASSWORD = "password";
	private static X509Certificate intermediateCertificate = null;
	private static final String FILE_MINICA_PEM = "lib/LibertyFATTestFiles/pebble.minica.pem";

	@ClassRule
	public static CAContainer pebble = new PebbleContainer();

	@Rule
	public ExpectedException expectedException = ExpectedException.none();

	@BeforeClass
	public static void beforeClass() throws Exception {

		/*
		 * Start a simple HTTP server to respond to challenges.
		 */
		challengeServer = new HttpChallengeServer(pebble.getHttpPort());

		try {
			challengeServer.start();
		} catch (IOException e) {
			Log.error(AcmeClientTest.class, "beforeClass", e);
		}

		try {
			/*
			 * Create temp files that we can use to create file paths.
			 */
			File truststore = File.createTempFile("truststore", "jks");
			File accountKey = File.createTempFile("accountKey", "pem");
			File domainKey = File.createTempFile("domainKey", "pem");
			TRUSTSTORE_FILE = truststore.getAbsolutePath();
			FILE_ACCOUNT_KEY = accountKey.getAbsolutePath();
			FILE_DOMAIN_KEY = domainKey.getAbsolutePath();

			/*
			 * Delete them so we can generate them in the test.
			 */
			truststore.delete();
			accountKey.delete();
			domainKey.delete();

			/*
			 * Delete the keys on exit.
			 */
			truststore.deleteOnExit();
			accountKey.deleteOnExit();
			domainKey.deleteOnExit();
		} catch (IOException e) {
			throw new RuntimeException(e.getMessage(), e);
		}

		/*
		 * Download the ACME CA's intermediate certificate and convert it from a
		 * PEM to an X.509 certificate and install it in a trust store.
		 */
		try {
			/*
			 * Retrieve the intermediate certificate that will be used to sign
			 * any generated certificates. This is re-generated on each run.
			 * 
			 * Currently, this test doesn't require this certificate, but this
			 * is just an example of how to do so for *real* tests that will
			 * verify that the generated certificate is actually signed by the
			 * root and intermediate certificates.
			 */
			intermediateCertificate = AcmeFatUtils.getX509Certificate(pebble.getAcmeCaIntermediateCertificate());
			Log.info(AcmeClientTest.class, "<cinit>",
					"Pebble Intermediate Cert: " + String.valueOf(intermediateCertificate));

			/*
			 * Get the certificate generated by miniCA for the ACME HTTPS API.
			 * This is static and required to be used to talk to ACME over
			 * HTTPS.
			 */
			Certificate acmeHttpsCert = AcmeFatUtils
					.getX509Certificate(Files.readAllBytes(new File(FILE_MINICA_PEM).toPath()));
			Log.info(AcmeClientTest.class, "<cinit>", "ACME HTTPS Cert: " + String.valueOf(acmeHttpsCert));

			/*
			 * Write it to a JKS.
			 */
			KeyStore ks = KeyStore.getInstance("JKS");
			ks.load(null, null);
			ks.setCertificateEntry("acme-https", acmeHttpsCert);
			ks.store(new FileOutputStream(TRUSTSTORE_FILE), TRUSTSTORE_PASSWORD.toCharArray());

		} catch (Exception e) {
			Log.error(AcmeClientTest.class, "<cinit>", e);
		}
	}

	@AfterClass
	public static void afterClass() throws Exception {
		if (challengeServer != null) {
			challengeServer.stop();
			challengeServer = null;
		}
	}

	/**
	 * Fetch a certificate for a single domain.
	 * 
	 * @throws Exception
	 */
	@Test
	public void fetchCertificate_SingleDomain() throws Exception {

		/*
		 * Create an AcmeService to test.
		 */
		AcmeClient acmeClient = createClient(TEST_DOMAIN_1);

		/*
		 * Get the certificate from the ACME CA server.
		 */
		AcmeCertificate newCertificate = acmeClient.fetchCertificate(false);

		/*
		 * Verify that the certificate returned from the ACME CA is signed by
		 * the ACME CA's intermediate certificate public key.
		 */
		newCertificate.getCertificate().verify(intermediateCertificate.getPublicKey());
		assertEquals("CN=" + TEST_DOMAIN_1, newCertificate.getCertificate().getSubjectDN().getName());
	}

	/**
	 * Test fetching a certificate form the ACME CA for several domains.
	 * 
	 * @throws Exception
	 */
	@Test
	public void fetchCertificate_MultiDomain_Success() throws Exception {

		/*
		 * Create an AcmeService to test.
		 */
		AcmeClient acmeClient = createClient(TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4);

		/*
		 * Get the certificate from the ACME CA server.
		 */
		AcmeCertificate newCertificate = acmeClient.fetchCertificate(false);

		/*
		 * Verify that the certificate returned from the ACME CA is signed by
		 * the ACME CA's intermediate certificate public key.
		 * 
		 * When processing multiple domains, the subject DN will be that of the
		 * first domain.
		 */
		newCertificate.getCertificate().verify(intermediateCertificate.getPublicKey());
		assertEquals("CN=" + TEST_DOMAIN_1, newCertificate.getCertificate().getSubjectDN().getName());
	}

	/**
	 * Verify that we can revoke a fetched certificate.
	 * 
	 * @throws Exception
	 */
	@Test
	public void fetchCertificate_Revoke() throws Exception {
		String method = "fetchCertificate_Revoke";
		/*
		 * Create an AcmeService to test.
		 */
		AcmeClient acmeClient = createClient(TEST_DOMAIN_1);

		/*
		 * Get the certificate from the ACME CA server.
		 */
		AcmeCertificate newCertificate;
		try {
			newCertificate = acmeClient.fetchCertificate(false);
		} catch (AcmeCaException e) {
			Log.error(AcmeClientTest.class, method, e, "Hit exception on fetchCertificate, sleep and retry");
			Thread.sleep(1000);
			newCertificate = acmeClient.fetchCertificate(false);
		}

		/*
		 * The certificate should be valid.
		 */
		assertEquals("The new certificate should be valid.", "Valid",
				pebble.getAcmeCertificateStatus(newCertificate.getCertificate()));

		/*
		 * Revoke the certificate.
		 */
		try {
			acmeClient.revoke(newCertificate.getCertificate(), null);
		} catch (AcmeCaException e) {
			Log.error(AcmeClientTest.class, method, e, "Hit exception on revoke, sleep and retry");
			Thread.sleep(1000);
			acmeClient.revoke(newCertificate.getCertificate(), null);
		}

		/*
		 * The certificate should now be revoked.
		 */
		assertEquals("The new certificate should be revoked.", "Revoked",
				pebble.getAcmeCertificateStatus(newCertificate.getCertificate()));
	}

	/**
	 * Create the AcmeClient using the directory URI and Account information.
	 * Also set the AcmeClient on the challenge server.
	 * 
	 * @return the created AcmeClient
	 */
	public AcmeClient createClient(String... domains) throws AcmeCaException {
		AcmeClient ac = new AcmeClient(getAcmeConfig(domains));
		challengeServer.setAcmeClient(ac);
		return ac;
	}

	/**
	 * Get a {@link AcmeConfig} instance for the test.
	 * 
	 * @param domains
	 *            Domains to configure.
	 * @return The {@link AcmeConfig} instance.
	 * @throws AcmeCaException
	 *             If the instance could not be created.
	 */
	private static AcmeConfig getAcmeConfig(String... domains) throws AcmeCaException {
		Map<String, Object> acmeProperties = new HashMap<String, Object>();
		acmeProperties.put(AcmeConstants.DOMAIN, domains);
		acmeProperties.put(AcmeConstants.DIR_URI, pebble.getAcmeDirectoryURI(true));
		acmeProperties.put(AcmeConstants.ACCOUNT_KEY_FILE, FILE_ACCOUNT_KEY);
		acmeProperties.put(AcmeConstants.DOMAIN_KEY_FILE, FILE_DOMAIN_KEY);
		return new AcmeConfig(acmeProperties);
	}
}
