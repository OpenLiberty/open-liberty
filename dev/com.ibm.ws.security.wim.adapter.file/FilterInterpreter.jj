/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. FilterInterpreter.jj */
/*@egen*/options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(FilterInterpreter)
/*******************************************************************************
 * Copyright (c) 2015 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************
 * 
 * Change History:
 * 
 * Tag           Person           Defect/Feature      Comments
 * ----------    ------           --------------      --------------------------------------------------
 */

package com.ibm.ws.security.wim.scim.parser;

public class FilterInterpreter/*@bgen(jjtree)*/implements FilterInterpreterTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTFilterInterpreterState jjtree = new JJTFilterInterpreterState();

/*@egen*/

}

PARSER_END(FilterInterpreter)

SKIP :
{
  " "
| "\n"
| "\r"
}

TOKEN :
{
  < DT: "\""
        (
          (["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"]) "-"
          (["0"-"1"] ["0"-"9"]) "-"
          (["0"-"3"] ["0"-"9"]) "T"
          (["0"-"9"] ["0"-"9"]) ":"
          (["0"-"9"] ["0"-"9"]) ":"
          (["0"-"9"] ["0"-"9"])
        )
        "\"" >
|
  < BOOL: ("true" | "false") >
|
  < ATTR_OP: ("eq" | "co" | "sw" | "pr" | "gt" | "ge" | "lt" | "le") >
|
  < LGCL_OP: "and" | "or" >
|
  < ATTRIBUTE: <LETTER> (<LETTER>|".")* <LETTER> >
|
  < NUM: ( <DIGIT> )+ >
|
  < LETTER: ["a"-"z"] >
|
  < DIGIT: ["0"-"9"] >
|
  < STR:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < LBRACE: "(" >
| 
  < RBRACE: ")" >

}

/** 
 http://www.simplecloud.info/specs/draft-scim-api-01.html#query-resources

 Each expression MUST contain an attribute name followed by an attribute operator and optional value.
 Multiple expressions MAY be combined using the two logical operators.
 Furthermore expressions can be grouped together using "()".
*/
SimpleNode parse() : {/*@bgen(jjtree) parse */
  SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) parse */
  try {
/*@egen*/
  Expression() <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    (SimpleExpression() | ( LBrace() Expression() RBrace() ) ) [ LgclOp() Expression() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LgclOp() :
{/*@bgen(jjtree) LgclOp */
  SimpleNode jjtn000 = new SimpleNode(JJTLGCLOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) LgclOp */
  try {
/*@egen*/
  t = <LGCL_OP>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RBrace() :
{/*@bgen(jjtree) RBrace */
  SimpleNode jjtn000 = new SimpleNode(JJTRBRACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) RBrace */
  try {
/*@egen*/
  t = <RBRACE>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LBrace() :
{/*@bgen(jjtree) LBrace */
  SimpleNode jjtn000 = new SimpleNode(JJTLBRACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) LBrace */
  try {
/*@egen*/
  t = <LBRACE>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SimpleExpression() : {/*@bgen(jjtree) SimpleExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTSIMPLEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleExpression */
  try {
/*@egen*/
  Attribute() AttrOp() [ Value() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AttrOp() :
{/*@bgen(jjtree) AttrOp */
  SimpleNode jjtn000 = new SimpleNode(JJTATTROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) AttrOp */
  try {
/*@egen*/
  t = <ATTR_OP>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Attribute() :
{/*@bgen(jjtree) Attribute */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) Attribute */
  try {
/*@egen*/
  t = <ATTRIBUTE>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Value() :
{/*@bgen(jjtree) Value */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) Value */
  try {
/*@egen*/
  t = <STR>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }
|
  t = <NUM>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }
|
  t = <DT>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }
|
  t = <BOOL>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}