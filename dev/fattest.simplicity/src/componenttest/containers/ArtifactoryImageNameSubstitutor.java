/*******************************************************************************
 * Copyright (c) 2020 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package componenttest.containers;

import org.testcontainers.utility.DockerImageName;
import org.testcontainers.utility.ImageNameSubstitutor;

import com.ibm.websphere.simplicity.log.Log;

import componenttest.topology.utils.ExternalTestService;

/**
 * An image name substituter is configured in testcontainers.properties and will transform docker image names.
 * Here we use it to apply a private registry prefix so that in remote builds we use an internal mirror
 * of Docker Hub, instead of downloading from Docker Hub in each build which causes rate limiting issues.
 */
public class ArtifactoryImageNameSubstitutor extends ImageNameSubstitutor {

    private static final Class<?> c = ArtifactoryImageNameSubstitutor.class;

    private static final String artifactoryRegistryKey = "fat.test.artifactory.download.server";

    @Override
    public DockerImageName apply(DockerImageName original) {
        // Priority 1: If we are using a synthetic image do not substitute nor cache
        if (isSyntheticImage(original)) {
            return original;
        }

        // Priority 2: If registry was explicit set, do not substitute
        if (original.getRegistry() != null && !original.getRegistry().isEmpty()) {
            return andVerifyImage(original);
        }

        // Priority 3: Ask the docker strategy if we should substitute the image.
        // This takes into account local/remote docker and properties to force the use of Artifactory.
        if (!ExternalTestServiceDockerClientStrategy.USE_ARTIFACTORY_NAME_SUBSTITUTION) {
            return andVerifyImage(original);
        }

        // Need to substitute image name to use private registry
        String privateImage = getPrivateRegistry() + '/' + original.asCanonicalNameString();
        Log.info(c, "apply", "Swapping docker image name from " + original.asCanonicalNameString() + " --> " + privateImage);
        return andVerifyImage(original, DockerImageName.parse(privateImage).asCompatibleSubstituteFor(original));
    }

    @Override
    protected String getDescription() {
        return "ArtifactoryImageNameSubstitutor";
    }

    /**
     * Docker images that are programmatically constructed at runtime (usually with ImageFromDockerfile)
     * will error out with a 404 if we attempt to do a docker pull from an Artifactory mirror registry.
     * To work around this issue, we will avoid image name substitution for image names that appear to be programmatically
     * generated by Testcontainers. FATs that use ImageFromDockerfile should consider using dedicated images
     * instead of programmatic construction (see com.ibm.ws.cloudant_fat/publish/files/couchdb-ssl/ for an example)
     */
    private static boolean isSyntheticImage(DockerImageName dockerImage) {
        String name = dockerImage.asCanonicalNameString();
        boolean isSynthetic = dockerImage.getRegistry().equals("localhost") && //
                              dockerImage.getRepository().split("/")[0].equals("testcontainers") && //
                              dockerImage.getVersionPart().equals("latest");
        boolean isCommittedImage = dockerImage.getRepository().equals("sha256");
        if (isSynthetic || isCommittedImage) {
            Log.warning(c, "WARNING: Cannot use private registry for programmatically built or committed image " + name +
                           ". Consider using a pre-built image instead.");
        }
        return isSynthetic || isCommittedImage;
    }

    static String getPrivateRegistry() {
        String artifactoryServer = System.getProperty(artifactoryRegistryKey);
        if (artifactoryServer == null || artifactoryServer.isEmpty() || artifactoryServer.startsWith("${"))
            throw new IllegalStateException("No private registry configured. System property '" + artifactoryRegistryKey + "' was: " + artifactoryServer);
        if (artifactoryServer.startsWith("na.") || artifactoryServer.startsWith("eu."))
            artifactoryServer = artifactoryServer.substring(3);
        return "wasliberty-docker-remote." + artifactoryServer;
    }

    static String getPrivateRegistryAuthToken() {
        try {
            String token = ExternalTestService.getProperty("docker-hub-mirror/auth-token");
            if (token == null || token.isEmpty() || token.startsWith("${"))
                throw new IllegalStateException("Unable to locate private registry auth token.");
            Log.info(c, "getPrivateRegistryAuthToken", "Got auth token starting with: " + token.substring(0, 4) + "....");
            return token;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Verifies image name has been documented to ensure we can generate an accurate list.
     */
    static DockerImageName andVerifyImage(DockerImageName original) {
        return andVerifyImage(original, null);
    }

    static DockerImageName andVerifyImage(DockerImageName original, DockerImageName output) {

        if (!ImageVerifier.hasImage(original)) {
            RuntimeException e = new RuntimeException("Used testcontainer image " + original.asCanonicalNameString() +
                                                      " was not defined in the autoFVT/fat.bnd.properties file! " +
                                                      "To correct this, add " + original.asCanonicalNameString() + " to the '" + ImageVerifier.imageProperty + "' " +
                                                      "property in the bnd.bnd or build-test.xml file for this FAT so that an testcontainer image " +
                                                      "graph can be generated in the future.");

            Log.error(c, "andVerifyImage", e);
            throw e;
        }

        return output == null ? original : output;
    }

}
