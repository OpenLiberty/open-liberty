/*******************************************************************************
 * Copyright (c) 2011 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package com.ibm.websphere.simplicity.application.loose;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Enumeration;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;

import com.ibm.websphere.simplicity.LocalFile;
import com.ibm.websphere.simplicity.Machine;
import com.ibm.websphere.simplicity.RemoteFile;

/**
 * Generates virtual archive XML files (aka "loose config" files) that describe physical ear/war applications.
 * This implementation is based on the virtual archive files generated by Eclipse tooling for v8.5 Alpha.
 */
public class VirtualArchiveFactory {

    private static final String CLASS_NAME = VirtualArchiveFactory.class.getName();
    private static final Logger LOG = Logger.getLogger(CLASS_NAME);

    private boolean usingVirtualWebModuleLibraries = false; // not sure if current Eclipse tooling supports this option

    /**
     * You can use this method to test the implementation without fully initializing Simplicity.
     * Before this will work, you have to create some property files and server.xml,
     * because Simplicity is a little weird like that.
     * 
     * @param args nothing
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        System.setProperty("local.properties", "C:\\blah2\\liberty\\local.properties");
        System.setProperty("bootstrapping.properties", "C:\\blah2\\liberty\\bootstrapping.properties");
        Machine localMachine = Machine.getLocalMachine();
        Machine remoteMachine = localMachine;

        // initialize inputs
        RemoteFile physicalArchive = new RemoteFile(localMachine, "C:\\blah2\\liberty\\apps\\resources.ear");
        RemoteFile virtualLocation = new RemoteFile(remoteMachine, "C:\\blah2\\liberty\\looseConfig");
        RemoteFile virtualArchive = new RemoteFile(remoteMachine, "C:\\blah2\\liberty\\vapps\\resources.ear");
        //        RemoteFile physicalArchive = new RemoteFile(localMachine, "C:/Storage/Workspaces/liberty/com.ibm.ws.webcontainer-8.0_fat/autoFVT/apps/webcontainer.watchdog.ear");
        //        RemoteFile virtualLocation = new RemoteFile(remoteMachine, "C:\\blah2\\liberty\\looseConfig");
        //        RemoteFile virtualArchive = new RemoteFile(remoteMachine, "C:\\blah2\\liberty\\vapps\\webcontainer.watchdog.ear");

        // extract archives and construct virtual archive
        VirtualArchiveFactory factory = new VirtualArchiveFactory();
        factory.extract(physicalArchive, virtualLocation, virtualArchive);

        // parse archive and display the result
        PrintWriter writer = new PrintWriter(System.out);
        factory.print(writer, factory.unmarshal(virtualArchive), 0);
        writer.flush();
    }

    /**
     * Deletes the physical files represented by a virtual archive. Does not delete the virtual archive XML file itself. Assumes that the virtual archive was created by this
     * factory; more specifically: assumes that all "sourceOnDisk" attributes are child files/directories of a parent directory in the current archive. The <b>parent directory</b>
     * of all "sourceOnDisk" attributes will be recursively deleted by this method!
     * 
     * @param machine the machine where the virtual archive resides
     * @param archive the virtual archive whose physical entries you want to delete
     * @throws Exception if deletion fails
     */
    public void delete(Machine machine, VirtualArchive archive) throws Exception {
        if (archive == null) {
            return;
        }
        for (FileEntry child : archive.getFileEntries()) {
            this.deleteParent(machine, child.getSourceOnDisk());
        }
        for (DirectoryEntry child : archive.getDirectoryEntries()) {
            this.deleteParent(machine, child.getSourceOnDisk());
        }
        for (VirtualArchive child : archive.getVirtualArchiveEntries()) {
            this.delete(machine, child);
        }
    }

    /**
     * Recursively deletes the parent directory of a specific file.
     * 
     * @param machine the machine you want to update
     * @param path the path to a file/directory whose parent directory you want to delete
     * @throws Exception if something odd happens
     */
    protected void deleteParent(Machine machine, String path) throws Exception {
        if (machine == null || path == null) {
            return;
        }
        RemoteFile file = machine.getFile(path);
        RemoteFile projectDir = file.getParentFile();
        if (projectDir.exists()) { // don't try to delete the file (or complain) if the file has already been deleted
            if (!projectDir.delete()) { // complain if deletion fails, but don't fail (want to try deleting all the other files/directories)
                LOG.warning("Failed to delete: " + this.describeFile(file));
            }
        }
    }

    /**
     * Prints an indented message
     * 
     * @param out the writer to print to
     * @param spaces indentation
     * @param msg the message to print
     */
    protected void print(PrintWriter out, int spaces, String msg) {
        for (int i = 0; i < spaces; i++) {
            out.print(" ");
        }
        out.println(msg);
    }

    /**
     * prints the contents of an archive to a writer
     * 
     * @param out the writer to print to
     * @param archive the archive to print
     * @param indent used to express nested archives; the immediate caller should use 0.
     */
    protected void print(PrintWriter out, VirtualArchive archive, int indent) {
        if (out == null) {
            return;
        }
        if (out == null || archive == null) {
            this.print(out, indent, "(archive is null)");
            return;
        }
        this.print(out, indent, archive.getClass().getSimpleName() + ":");
        int nextIndent = indent + 2;
        this.print(out, nextIndent, "TargetInArchive : " + archive.getTargetInArchive());
        for (FileEntry child : archive.getFileEntries()) {
            this.print(out, nextIndent, child.getClass().getSimpleName() + ":");
            this.print(out, nextIndent + 2, "SourceOnDisk    : " + child.getSourceOnDisk());
            this.print(out, nextIndent + 2, "TargetInArchive : " + child.getTargetInArchive());
        }
        for (DirectoryEntry child : archive.getDirectoryEntries()) {
            this.print(out, nextIndent, child.getClass().getSimpleName() + ":");
            this.print(out, nextIndent + 2, "SourceOnDisk    : " + child.getSourceOnDisk());
            this.print(out, nextIndent + 2, "Excludes        : " + child.getExcludes());
            this.print(out, nextIndent + 2, "TargetInArchive : " + child.getTargetInArchive());
        }
        for (VirtualArchive child : archive.getVirtualArchiveEntries()) {
            this.print(out, child, nextIndent);
        }
    }

    /**
     * Expresses the current state of a virtual archive in an XML document.
     * 
     * @param sourceArchive the Java object you want to marshal
     * @return the file generated by this method (stored on the local machine)
     * @throws Exception if generation fails
     */
    public LocalFile marshal(VirtualArchive sourceArchive) throws Exception {
        JAXBContext context = JAXBContext.newInstance(VirtualArchive.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        String targetInArchive = sourceArchive.getTargetInArchive(); // cache current value (in case it's set)
        sourceArchive.setTargetInArchive(null); // top-level virtual archive should never set this attribute
        File result = File.createTempFile("virtualArchive", ".xml");
        result.getParentFile().mkdirs();
        marshaller.marshal(sourceArchive, result);
        //        marshaller.marshal(this, System.out);
        sourceArchive.setTargetInArchive(targetInArchive); // restore original value (in case it's set)
        return this.createLocalFile(result);
    }

    /**
     * Converts a virtual archive XML file into a series of Java objects.
     * 
     * @param sourceFile a virtual archive XML file. If the input file does not end with ".xml", the ".xml" extension will automatically be added.
     * @return a Java object representation of the virtual archive, or null if the input file is null or does not exist
     * @throws Exception if the XML file can't be parsed
     */
    public VirtualArchive unmarshal(RemoteFile sourceFile) throws Exception {
        // Step 1: ensure the file has an XML extension
        if (sourceFile == null) {
            return null;
        }
        RemoteFile remoteArchive = this.ensureExtension(sourceFile, ".xml");
        if (!remoteArchive.exists()) {
            return null;
        }

        // Step 2: ensure the file is local
        boolean fileIsLocal = remoteArchive.getMachine().isLocal();
        File file = null;
        if (fileIsLocal) {
            file = new File(remoteArchive.getAbsolutePath());
        } else {
            file = File.createTempFile("virtualArchive", ".xml");
            remoteArchive.copyToDest(this.createLocalFile(file));
        }

        // Step 3: Unmarshall XML
        JAXBContext context = JAXBContext.newInstance(VirtualArchive.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        VirtualArchive result = (VirtualArchive) unmarshaller.unmarshal(file);

        // Step 4: Delete tmp file (if necessary) and return result
        if (!fileIsLocal) {
            file.delete();
        }
        return result;
    }

    /**
     * <p>
     * Extracts an application to a series of directories, and generates a virtual archive that represents the original physical archive.
     * </p>
     * Implementation:<ol>
     * <li>Copy original archive file to the local machine (if it is not already on the local machine)</li>
     * <li>Extract archive file to local temporary directory</li>
     * <li>Recursively extract child archives</li>
     * <li>Move remaining files to remote machine</li>
     * <li>Return in-memory representation of virtual archive</li>
     * </ol>
     * Performance:<ul>
     * <li>
     * Since we need to extract archives and additionally rearrange the extracted files to simulate a series of Eclipse projects, we need to consider the
     * way that Simplicity copies files remotely. When Simplicity copies file A to file B on machine M, and M is not the local machine, Simplicity actuall copies A to the local
     * machine and then copies A to the remote machine as B. Consequently, it's faster to extract/rearrange all files locally before transferring any files to the remote
     * device.
     * </li>
     * <li>
     * See javadoc on the <code>moveDirectory</code> for more performance information.
     * </li>
     * </ul>
     * 
     * @see #moveDirectory(RemoteFile, RemoteFile, VirtualArchive, String)
     * @param physicalArchive the application to extract
     * @param extractLocation the directory where you want to extract the application. Machine must match <code>virtualArchive</code>.
     * @param virtualArchive the XML file where you want to describe the virtual archive. Machine must match <code>virtualLocation</code>. If the input file does not end with
     *            ".xml", the ".xml" extension will automatically be added.
     * @throws Exception if any problem occurs
     */
    public void extract(RemoteFile physicalArchive, RemoteFile extractLocation, RemoteFile virtualArchive) throws Exception {
        RemoteFile remoteArchive = this.ensureExtension(virtualArchive, ".xml");
        if (LOG.isLoggable(Level.INFO)) {
            LOG.info("Extracting an archive using a loose configuration");
            LOG.info("  Physical Archive : " + this.describeFile(physicalArchive));
            LOG.info("  Extract Location : " + this.describeFile(extractLocation));
            LOG.info("  Virtual Archive  : " + this.describeFile(remoteArchive));
            LOG.info("  Use Virtual Web Module Libraries: " + this.isUsingVirtualWebModuleLibraries());
        }
        if (!physicalArchive.exists()) {
            throw new IllegalArgumentException("Physical archive does not exist: " + this.describeFile(physicalArchive));
        }
        if (!extractLocation.getMachine().getHostname().equals(virtualArchive.getMachine().getHostname())) {
            throw new IOException("The extract location and virtual archive must reside on the same machine.  Location=" + this.describeFile(extractLocation) + ", Archive="
                                  + this.describeFile(virtualArchive));
        }
        long start = System.currentTimeMillis();
        VirtualArchive archive = this.extract(physicalArchive, extractLocation);
        LocalFile localArchive = this.marshal(archive);
        if (!localArchive.copyToDest(remoteArchive)) {
            throw new IOException("Failed to copy " + this.describeFile(localArchive) + " to " + this.describeFile(remoteArchive));
        }
        if (LOG.isLoggable(Level.INFO)) {
            LOG.info("Contents of virtual archive ...");
            this.logFileContents(localArchive, true);
            LOG.info("Extraction complete.  Time elapsed: " + (System.currentTimeMillis() - start) + " ms");
        }
        localArchive.delete(); // tmp file no longer needed
    }

    /**
     * Extracts an application to a directory, returns a virtual representation of that archive
     * 
     * @param physicalArchive the application to extract
     * @param extractLocation the directory where you want to extract the application
     * @return a virtual representation of that archive, or null if this instance doesn't know how to extract the archive
     * @throws Exception if any problem occurs
     */
    protected VirtualArchive extract(RemoteFile physicalArchive, RemoteFile extractLocation) throws Exception {
        // Step 0: validate input
        String ext = this.getExtension(physicalArchive.getName());
        if (!this.isSupported(ext)) {
            return null; // don't do anything if the input archive is not supported (fail fast for recursive calls)
        }

        // Step 1: Copy original archive file to the local machine (if it is not already on the local machine)
        extractLocation.mkdirs(); // will throw NPE if targetDir is null (expected)
        if (!extractLocation.isDirectory()) {
            throw new IllegalArgumentException("Failed to create directory: " + this.describeFile(extractLocation));
        }
        boolean appIsLocal = physicalArchive.getMachine().isLocal();
        File localArchive = null;
        if (appIsLocal) {
            localArchive = new File(physicalArchive.getAbsolutePath());
        } else {
            localArchive = File.createTempFile("archive", null);
            physicalArchive.copyToDest(this.createLocalFile(localArchive));
        }

        // Step 2: Extract the archive file to a local temporary directory
        File tmpDir = File.createTempFile("archiveDir", null);
        tmpDir.delete(); // we don't want the file, we just want the abstract path name (for a directory)
        this.unzip(localArchive, tmpDir);
        if (!appIsLocal) {
            localArchive.delete(); // we don't need the local copy now that we've extracted it
        }

        // Step 3: Recursively extract child archives
        VirtualArchive archive = new VirtualArchive();
        // always search child archives of ears, but only search child archives of wars if this.usingVirtualWebModuleLibraries
        if ("ear".equals(ext) || ("war".equals(ext) && this.isUsingVirtualWebModuleLibraries())) {
            Set<File> children = this.getAllChildren(tmpDir, new TreeSet<File>()); // TreeSet sorts File paths alphabetically (ensures consistent ordering in virtual archive)
            for (File child : children) {
                RemoteFile childFile = this.createLocalFile(child);
                VirtualArchive childArchive = this.extract(childFile, extractLocation);
                if (childArchive != null) { // in other words, if the child really was an archive
                    String targetInArchive = this.forwardSlashes(child.getAbsolutePath().substring(tmpDir.getAbsolutePath().length() + 1));
                    childArchive.setTargetInArchive(targetInArchive);
                    archive.getVirtualArchiveEntries().add(childArchive);
                    child.delete(); // don't copy this child twice                    
                }
            }
        }

        // Step 4: Move remaining files to remote machine
        /*-
         * The following line avoids directory name conflicts by
         * generating a unique file name based on the archive type.
         * This implementation is safe as long as we don't install 
         * more than 9999 archives of any single type.
         */
        RemoteFile remoteProjectDir = extractLocation.getOrderedChild(ext, 4, null); // see note above
        remoteProjectDir.mkdirs();
        RemoteFile localTmpDir = this.createLocalFile(tmpDir);
        if ("ear".equals(ext)) {
            RemoteFile remoteEarContent = new RemoteFile(remoteProjectDir, "EarContent");
            this.moveDirectory(localTmpDir, remoteEarContent, archive, "/");
        } else if ("war".equals(ext)) {
            RemoteFile localWebInfDir = new RemoteFile(localTmpDir, "WEB-INF");
            RemoteFile localClassesDir = new RemoteFile(localWebInfDir, "classes");
            if (localClassesDir.exists()) {
                RemoteFile remoteBuildDir = new RemoteFile(remoteProjectDir, "build");
                RemoteFile remoteClassesDir = new RemoteFile(remoteBuildDir, "classes");
                this.moveDirectory(localClassesDir, remoteClassesDir, archive, "/WEB-INF/classes");
            }
            RemoteFile localSrcDir = new RemoteFile(localWebInfDir, "source");
            if (localSrcDir.exists()) {
                RemoteFile remoteSrcDir = new RemoteFile(remoteProjectDir, "src");
                this.moveDirectory(localSrcDir, remoteSrcDir, archive, "/WEB-INF/source");
            }
            RemoteFile remoteWebContent = new RemoteFile(remoteProjectDir, "WebContent");
            this.moveDirectory(localTmpDir, remoteWebContent, archive, "/");
        } else if ("jar".equals(ext)) {
            RemoteFile remoteBuildDir = new RemoteFile(remoteProjectDir, "build");
            RemoteFile remoteClassesDir = new RemoteFile(remoteBuildDir, "classes");
            this.moveDirectory(localTmpDir, remoteClassesDir, archive, "/");
        }

        // Step 5: Return in-memory representation of virtual archive
        return archive;
    }

    /**
     * <p>
     * Copies a directory from the local machine to the remote machine, and updates a virtual archive with the result of the transfer.
     * </p>
     * <p>
     * POTENTIAL PERFORMANCE PROBLEM:
     * The current implementation uses Simplicity to transfer files one at a time from the source directory to the target directory.
     * This implementation is efficient when the source and target machines are both local, but inefficient when either machine is remote.
     * For applications with very large numbers of files, this transfer may be very slow.
     * </p>
     * <p>
     * HOW TO FIX IT:
     * The concept is simple: zip the source directory, transfer the zip, and extract the zip on the remote machine.
     * The implementation is tricky because you'll need a JRE on both remote machines to handle the zip/unzip operations.
     * Technically, this protected method is ONLY called with sourceDir is local, so you can use the <code>java.util.zip</code> package for zipping (see unzip method in this
     * class).
     * You'll have to use the Liberty server's JRE for unzipping on the target machine. Since instances of this class currently don't have a reference to a liberty server, the JVM
     * that you intend to use should be passed in through the constructor or a member method.
     * Recommendation: use a <code>Map&lt;Machine, String&gt;</code> variable to map machines to JRE paths, and then reference the map to determine the path to the JRE for a
     * particular remote machine.
     * </p>
     * 
     * @param sourceDir the source directory (currently always local)
     * @param targetDir the target directory (currently sometimes remote, and currently is the Machine with Liberty installed)
     * @param archive the virtual archive to update after the transfer is complete
     * @param targetInArchive the target for the transferred directory in the virtual archive
     * @throws Exception if the transfer fails
     */
    protected void moveDirectory(RemoteFile sourceDir, RemoteFile targetDir, VirtualArchive archive, String targetInArchive) throws Exception {
        boolean recursive = true; // we want to recursively copy all files
        boolean overwrite = true; // this value shouldn't matter
        sourceDir.copyToDest(targetDir, recursive, overwrite);
        sourceDir.delete(); // transfer complete, recursively delete local trash (and avoid redundant transfer later on)
        // we specifically WANT to use the fully qualified path because that's what the Eclipse tooling does
        String sourceOnDisk = targetDir.getAbsolutePath();
        archive.getDirectoryEntries().add(new DirectoryEntry(sourceOnDisk, targetInArchive));
    }

    /**
     * Logs the contents of a File. If <code>singleLine=true</code>, then the whole File will be logged as one single message. Otherwise, each invidivual line in the file will be
     * logged separately. Some logging formatters look prettier with single line log messages; others look better with multiple-line log messages.
     * 
     * @param file the file whose contents you want to log.
     * @param singleLine true to log the whole file in one message, false to log each individual line
     */
    protected void logFileContents(LocalFile file, boolean singleLine) {
        BufferedReader reader = null;
        try {
            StringWriter stringWriter = null; // Closing a StringWriter has no effect.
            PrintWriter printWriter = null;
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(file.getAbsolutePath())));
            if (singleLine) {
                stringWriter = new StringWriter();
                printWriter = new PrintWriter(stringWriter);
            }
            String line;
            while ((line = reader.readLine()) != null) {
                if (singleLine) {
                    printWriter.println(line);
                } else {
                    LOG.info(line);
                }
            }
            if (singleLine) {
                LOG.info(stringWriter.toString());
            }
        } catch (IOException e) {
            LOG.info("Failed to log contents of file: " + file + ".  Exception: " + e.getMessage());
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    LOG.info("Failed to close reader for file: " + file + ".  Exception: " + e.getMessage());
                }
            }
        }
    }

    /**
     * Produces a file with the specified extension.
     * 
     * @param remoteFile the original file to examine
     * @param extension the desired file extension
     * @return Returns null if the input file is null. If the name of the input file already ends in the correct extension, then the input file is returned. If it does not, then
     *         the correct extension is
     *         appended to the name of the file, and the resulting <code>RemoteFile</code> is returned.
     * @throws Exception if the path cannot be built
     */
    protected RemoteFile ensureExtension(RemoteFile remoteFile, String extension) throws Exception {
        if (remoteFile == null) {
            return null;
        }
        String name = remoteFile.getName();
        if (!name.endsWith(extension)) {
            return new RemoteFile(remoteFile.getParentFile(), name + extension);
        }
        return remoteFile;
    }

    /**
     * Describes the host and path name of a file instance
     * 
     * @param remoteFile a file to examine
     * @return a description of the file
     */
    protected String describeFile(RemoteFile remoteFile) {
        String host = "(null)";
        String path = "(null)";
        if (remoteFile != null) {
            path = remoteFile.getAbsolutePath();
            Machine machine = remoteFile.getMachine();
            if (machine != null) {
                host = machine.getHostname();
            }
        }
        return host + ":" + path;
    }

    /**
     * Constructs a LocalFile instance using a <code>java.io.File</code> instance.
     * It seems like this method should be a direct LocalFile constructor.
     * 
     * @param file the file you want to represent
     * @return a new LocalFile instance for the input <code>java.io.File</code> instance.
     * @throws Exception if bootstrapping.properties is wrong (really? why should that matter?)
     */
    protected LocalFile createLocalFile(File file) throws Exception {
        return new LocalFile(file.getAbsolutePath());
    }

    /**
     * Extracts a local file to a local target directory.
     * 
     * @param source the file to extract
     * @param targetDir the directory to extract the file to
     * @throws IOException if extraction fails
     */
    protected void unzip(File source, File targetDir) throws IOException {
        targetDir.mkdirs();
        ZipFile zipFile = null;
        try {
            zipFile = new ZipFile(source);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                File newFile = new File(targetDir, entry.getName());
                if (entry.isDirectory()) {
                    newFile.mkdirs();
                } else {
                    // make sure the parent directory exists (entries may be extractd out of order)
                    newFile.getParentFile().mkdirs();
                    InputStream in = new BufferedInputStream(zipFile.getInputStream(entry));
                    OutputStream out = new BufferedOutputStream(new FileOutputStream(newFile));
                    this.redirect(in, out);
                }
            }
        } finally {
            if (zipFile != null) {
                zipFile.close();
            }
        }
    }

    /**
     * Reads the input stream and writes every byte to the output stream. Closes both streams when the end of the input stream is reached.
     * 
     * @param in the stream to read
     * @param out the stream to write
     * @throws IOException if redirection fails for any reason
     */
    protected void redirect(InputStream in, OutputStream out) throws IOException {
        byte[] buffer = new byte[2048];
        int len;
        try {
            while ((len = in.read(buffer)) >= 0) {
                out.write(buffer, 0, len);
            }
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (Exception e) {
                    LOG.logp(Level.FINE, CLASS_NAME, "redirect", "Failed to close input stream", e);
                }
            }
            if (out != null) {
                try {
                    out.flush();
                } catch (Exception e) {
                    LOG.logp(Level.FINE, CLASS_NAME, "redirect", "Failed to flush output stream", e);
                }
                try {
                    out.close();
                } catch (Exception e) {
                    LOG.logp(Level.FINE, CLASS_NAME, "redirect", "Failed to close output stream", e);
                }
            }
        }
    }

    /**
     * Recursively searches a file/directory for all child files/directories. Stores all results in the input set.
     * 
     * @param file the file/directory to search. Cannot be null.
     * @param children the cache to store all child files/directories. Cannot be null.
     * @return the input set after children are recursively added
     */
    protected Set<File> getAllChildren(File file, Set<File> children) {
        File[] immediateChildren = file.listFiles();
        if (immediateChildren != null) {
            for (File child : immediateChildren) {
                if (child == null) {
                    continue;
                }
                children.add(child);
                this.getAllChildren(child, children);
            }
        }
        return children;
    }

    /**
     * Replaces all back slashes in the input string with forward slashes.
     * 
     * @param string A String to mangle
     * @return the input string with all forward slashes
     */
    protected String forwardSlashes(String string) {
        return string.replace("\\", "/");
    }

    //    public boolean isSupported(RemoteFile file) throws Exception {
    //        return this.isSupported(this.getExtension(file.getName()));
    //    }

    /**
     * This implementation only knows how to generate a loose archive for Java, Web, and Enterprise archives.
     * Supported extensions include "jar", "war", and "ear".
     * 
     * @param file the file to examine
     * @return true if this instance can abstract the input file as a virtual archive
     * @throws Exception never; file.getName() shouldn't declare this throws clause
     */
    public boolean isSupported(RemoteFile file) throws Exception {
        return this.isSupported(this.getExtension(file.getName()));
    }

    protected boolean isSupported(String extension) {
        if ("ear".equals(extension)) {
            return true;
        } else if ("war".equals(extension)) {
            return true;
        } else if ("jar".equals(extension)) {
            return true;
        }
        return false;
    }

    /**
     * @return true if virtual archives should be used for child libraries of web modules, false if physical archives should be used
     */
    public boolean isUsingVirtualWebModuleLibraries() {
        return usingVirtualWebModuleLibraries;
    }

    /**
     * Configure this factory to create virtual/physical archives for child libraries of web modules
     * 
     * @param useVirtualWebModuleLibraries true to create virtual archives for web module library files (under WEB-INF/lib); false to create physical archives
     */
    public void setUsingVirtualWebModuleLibraries(boolean useVirtualWebModuleLibraries) {
        this.usingVirtualWebModuleLibraries = useVirtualWebModuleLibraries;
    }

    /**
     * Derives the extension of the input file name
     * 
     * @param fileName the name of the file whose extension you want to examine
     * @return the extension of the file
     */
    protected String getExtension(String fileName) {
        if (fileName == null) {
            return null;
        }
        int lastDotIndex = fileName.lastIndexOf(".");
        if (-1 < lastDotIndex && lastDotIndex < fileName.length()) {
            return fileName.substring(lastDotIndex + 1).toLowerCase();
        }
        return null;
    }

}
