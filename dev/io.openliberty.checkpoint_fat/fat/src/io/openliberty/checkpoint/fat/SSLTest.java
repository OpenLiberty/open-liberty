/*******************************************************************************
 * Copyright (c) 2022 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package io.openliberty.checkpoint.fat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.KeyStore;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

import com.ibm.websphere.simplicity.RemoteFile;
import com.ibm.websphere.simplicity.ShrinkHelper;
import com.ibm.websphere.simplicity.log.Log;

import componenttest.annotation.SkipIfCheckpointNotSupported;
import componenttest.custom.junit.runner.FATRunner;
import componenttest.topology.impl.LibertyServer;
import componenttest.topology.impl.LibertyServerFactory;
import io.openliberty.checkpoint.spi.CheckpointPhase;

@RunWith(FATRunner.class)
@SkipIfCheckpointNotSupported
public class SSLTest {
    @Rule
    public TestName testName = new TestName();

    public static LibertyServer server;

    private static final Class<?> c = SSLTest.class;
    private final String APP_NAME = "app2";
    private final String KEYSTORE_GENERATED = "CWPKI0803A";
    private final String TCP_CHANNEL_STARTED = "CWWKO0219I:.*defaultHttpEndpoint-ssl";

    @Before
    public void beforeEach() throws Exception {
        server = LibertyServerFactory.getLibertyServer("checkpointSSL-" + testName.getMethodName());
        ShrinkHelper.defaultApp(server, APP_NAME, "app2");
        FATSuite.copyAppsAppToDropins(server, APP_NAME);
    }

    @After
    public void tearDown() throws Exception {
        server.stopServer();
    }

    @Test
    public void configuredAutoGeneratedSSL() throws Exception {
        server.setCheckpoint(CheckpointPhase.APPLICATIONS, false, null);
        server.startServer(testName.getMethodName() + ".log");
        assertEquals("Expected checkpoint message not found", 1, server.findStringsInLogs("CWWKC0451I", server.getDefaultLogFile()).size());
        server.checkpointRestore();
        assertEquals("Expected restore message not found", 1, server.findStringsInLogs("CWWKC0452I", server.getDefaultLogFile()).size());
        assertNotNull("Expected CWPKI0803A message not found", server.waitForStringInLog(KEYSTORE_GENERATED));
        validateGeneratedKeyStore(server, "liberty");

        RemoteFile ksRemoteFile = server.getFileFromLibertyServerRoot("resources/security/key.p12");
        final String ksPath = ksRemoteFile.getAbsolutePath();
        final String ksPassword = "liberty";
        final String tsPath = null;
        final String tsPassword = null;

        assertNotNull("Ecpected CWWKO0219I message not found", server.waitForStringInLog(TCP_CHANNEL_STARTED));

        String result = sendHttpsGet("app2/request", server, ksPath, ksPassword, tsPath, tsPassword);
        assertNotNull(result);
        assertEquals("Expected response not found.", "Got ServletA", result);
    }

    @Test
    public void envPasswordOnCheckpointSSL() throws Exception {
        server.setCheckpoint(CheckpointPhase.APPLICATIONS, false, null);
        server.startServer(testName.getMethodName() + ".log");
        assertEquals("Expected checkpoint message not found", 1, server.findStringsInLogs("CWWKC0451I", server.getDefaultLogFile()).size());
        server.checkpointRestore();
        assertEquals("Expected restore message not found", 1, server.findStringsInLogs("CWWKC0452I", server.getDefaultLogFile()).size());
        assertNotNull("Expected CWPKI0803A message not found", server.waitForStringInLog(KEYSTORE_GENERATED));
        validateGeneratedKeyStore(server, server.getServerEnv().getProperty("keystore_password"));

        RemoteFile ksRemoteFile = server.getFileFromLibertyServerRoot("resources/security/key.p12");
        final String ksPath = ksRemoteFile.getAbsolutePath();
        final String ksPassword = server.getServerEnv().getProperty("keystore_password");
        final String tsPath = null;
        final String tsPassword = null;

        assertNotNull("Ecpected CWWKO0219I message not found", server.waitForStringInLog(TCP_CHANNEL_STARTED));

        String result = sendHttpsGet("app2/request", server, ksPath, ksPassword, tsPath, tsPassword);
        assertNotNull(result);
        assertEquals("Expected response not found.", "Got ServletA", result);
    }

    @Test
    public void envPasswordOnRestoreSSL() throws Exception {
        server.setCheckpoint(CheckpointPhase.APPLICATIONS, false, null);
        server.startServer(testName.getMethodName() + ".log");
        assertEquals("Expected checkpoint message not found", 1, server.findStringsInLogs("CWWKC0451I", server.getDefaultLogFile()).size());

        server.copyFileToLibertyServerRoot("sslKeystore/server.env");
        server.checkpointRestore();
        assertEquals("Expected restore message not found", 1, server.findStringsInLogs("CWWKC0452I", server.getDefaultLogFile()).size());
        assertNotNull("Expected CWPKI0803A message not found", server.waitForStringInLog(KEYSTORE_GENERATED));
        validateGeneratedKeyStore(server, server.getServerEnv().getProperty("keystore_password"));

        RemoteFile ksRemoteFile = server.getFileFromLibertyServerRoot("resources/security/key.p12");
        final String ksPath = ksRemoteFile.getAbsolutePath();
        final String ksPassword = server.getServerEnv().getProperty("keystore_password");
        final String tsPath = null;
        final String tsPassword = null;

        assertNotNull("Ecpected CWWKO0219I message not found", server.waitForStringInLog(TCP_CHANNEL_STARTED));

        String result = sendHttpsGet("app2/request", server, ksPath, ksPassword, tsPath, tsPassword);
        assertNotNull(result);
        assertEquals("Expected response not found.", "Got ServletA", result);
    }

    @Test
    public void configuredSSL() throws Exception {
        server.setCheckpoint(CheckpointPhase.APPLICATIONS, false, null);
        server.startServer(testName.getMethodName() + ".log");
        assertEquals("Expected checkpoint message not found", 1, server.findStringsInLogs("CWWKC0451I", server.getDefaultLogFile()).size());
        server.checkpointRestore();
        assertEquals("Expected restore message not found", 1, server.findStringsInLogs("CWWKC0452I", server.getDefaultLogFile()).size());

        RemoteFile ksRemoteFile = server.getFileFromLibertyServerRoot("resources/security/server-keystore.jks");
        final String ksPath = ksRemoteFile.getAbsolutePath();
        RemoteFile tsRemoteFile = server.getFileFromLibertyServerRoot("resources/security/server-truststore.jks");
        final String tsPath = ksRemoteFile.getAbsolutePath();

        final String ksPassword = "secret";
        final String tsPassword = "secret";

        assertNotNull("Ecpected CWWKO0219I message not found", server.waitForStringInLog(TCP_CHANNEL_STARTED));

        String result = sendHttpsGet("app2/request", server, ksPath, ksPassword, tsPath, tsPassword);
        assertNotNull(result);
        assertEquals("Expected response not found.", "Got ServletA", result);
    }

    public static String sendHttpsGet(String url, LibertyServer server, String ksPath, String ksPassword, String tsPath, String tsPassword) throws Exception {

        String result = null;
        SSLContext sslcontext = SSLContext.getInstance("SSL");

        establishSSLcontext(sslcontext, server, ksPath, ksPassword, tsPath, tsPassword);

        URL requestUrl = getURL(url, server);

        HttpsURLConnection httpsConn = (HttpsURLConnection) requestUrl.openConnection();
        httpsConn.setHostnameVerifier(new MyHostnameVerifier());
        httpsConn.setSSLSocketFactory(sslcontext.getSocketFactory());
        httpsConn.setRequestMethod("GET");
        httpsConn.setDoOutput(false);
        httpsConn.setDoInput(true);

        int code = httpsConn.getResponseCode();
        assertEquals("Expected response code not found.", 200, code);

        BufferedReader in = new BufferedReader(new InputStreamReader(httpsConn.getInputStream()));
        String temp = in.readLine();

        while (temp != null) {
            if (result != null)
                result += temp;
            else
                result = temp;
            temp = in.readLine();
        }
        return result;
    }

    private static void establishSSLcontext(SSLContext sslcontext, LibertyServer server, String ksPath, String ksPassword, String tsPath, String tsPassword) throws Exception {
        InputStream ksStream = null;
        InputStream tsStream = null;

        try {
            KeyManager keyManagers[] = null;

            if (ksPath != null) {
                KeyManagerFactory kmFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
                File ksFile = new File(ksPath);
                KeyStore keyStore = null;
                try {
                    keyStore = KeyStore.getInstance("JKS");
                    ksStream = new FileInputStream(ksFile);
                    keyStore.load(ksStream, ksPassword.toCharArray());
                } catch (Exception e) {
                    try {
                        keyStore = KeyStore.getInstance("PKCS12");
                        ksStream = new FileInputStream(ksFile);
                        keyStore.load(ksStream, ksPassword.toCharArray());
                    } catch (Exception e1) {
                        throw e1;
                    }

                }

                kmFactory.init(keyStore, ksPassword.toCharArray());
                keyManagers = kmFactory.getKeyManagers();
            }
            TrustManager[] trustManagers = null;

            if (tsPath != null) {
                TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                File tsFile = new File(tsPath);
                KeyStore trustStore = null;
                try {
                    trustStore = KeyStore.getInstance("JKS");
                    tsStream = new FileInputStream(tsFile);
                    trustStore.load(tsStream, tsPassword.toCharArray());

                } catch (Exception e) {
                    try {
                        trustStore = KeyStore.getInstance("PKCS12");
                        tsStream = new FileInputStream(tsFile);
                        trustStore.load(tsStream, tsPassword.toCharArray());
                    } catch (Exception e1) {
                        throw e1;
                    }

                }

                tmFactory.init(trustStore);
                trustManagers = tmFactory.getTrustManagers();
            }
            if (trustManagers == null) {
                trustManagers = getTrustManager();
            }

            sslcontext.init(keyManagers, trustManagers, null);
        } finally {
            if (ksStream != null) {
                ksStream.close();
            }
            if (tsStream != null) {
                tsStream.close();
            }
        }
    }

    private static TrustManager[] getTrustManager() {
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            @Override
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            @Override
            public void checkClientTrusted(
                                           java.security.cert.X509Certificate[] certs, String authType) {
            }

            @Override
            public void checkServerTrusted(
                                           java.security.cert.X509Certificate[] certs, String authType) {
            }
        } };

        return trustAllCerts;
    }

    private static URL getURL(String path, LibertyServer server) throws MalformedURLException {
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        return new URL("https://" + server.getHostname() + ":" + server.getHttpDefaultSecurePort() + path);

    }

    private static void validateGeneratedKeyStore(LibertyServer server, String password) throws Exception {
        String m = "validateGeneratedKeyStore";
        File keystore = new File(server.getFileFromLibertyServerRoot("resources/security/key.p12").getAbsolutePath());
        if (!keystore.exists())
            fail("Keystore was not generated at location: " + keystore.getAbsolutePath());
        Log.info(c, m, "Keystore exists at " + keystore.getAbsolutePath());

        Log.info(c, m, "Verifying that keystore is accessible using password=" + password);
        KeyStore ks = KeyStore.getInstance("PKCS12");
        ks.load(new FileInputStream(keystore), password.toCharArray());
    }

}

class MyHostnameVerifier implements HostnameVerifier {

    @Override
    public boolean verify(String hostname, SSLSession session) {
        return true;
    }
}