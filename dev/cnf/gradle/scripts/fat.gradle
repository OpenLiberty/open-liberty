/*******************************************************************************
 * Copyright (c) 2017 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
// Global vars
def autoFvtDir = "${buildDir}/autoFVT"
def publishDir = autoFvtDir + "/publish"

publishing {
  publications {
    maven(MavenPublication) {
      artifactId project.name
      version project.version
      artifact zipProjectFVT
    }
  }
}

task cleanFat() {
  doLast {
    delete autoFvtDir
  }
}

task cleanBeforeRun() {
  doLast {
    delete autoFvtDir + "/output/", autoFvtDir + "/results"
  }
}

task addRequiredLibraries {
  shouldRunAfter cleanFat
  shouldRunAfter jar
  def props = new Properties()
  file("${rootDir}/generated.properties").withInputStream { props.load(it) }
  repositories {
    if (usrHomeProps.exists() && !props.getProperty('artifactory.force.external.repo')) {
      // If Artifactory is available, use it
      maven {
        credentials {
          username props.getProperty("artifactory.download.user")
          password props.getProperty("artifactory.download.token")
        }
        url ("https://" + props.getProperty("artifactory.download.server") + "/artifactory/wasliberty-open-liberty")
      }
    } else {
      // Otherwise, use public maven
      mavenCentral()
      maven {
        url ("http://public.dhe.ibm.com/ibmdl/export/pub/software/openliberty/wasliberty-open-liberty/")
      }
    }
  }
  configurations {
    libs
  }
}

task copyFeatureBundles {
  shouldRunAfter assemble
  enabled file("${projectDir}/test-bundles").exists()
  doLast {
    file("${buildDir}/buildfiles").eachLine { String line ->
      if(!line.contains(project.name + ".jar")) {
        copy {
          from line
          into "${buildDir}/autoFVT/publish/files/bundles"
        }
      }
    }
  }
}

task autoFVT {
  dependsOn jar
  dependsOn copyMavenLibs
  dependsOn addRequiredLibraries
  dependsOn copyFeatureBundles
  enabled new File("${projectDir}/fat").exists()

  // For now we are just forcing the autoFVT create every time, this will be fixed
  // TODO: Be smart about when to recreate the autoFVT.zip
  doLast {
    // Copy the compiled classes
    copy {
      from compileJava.destinationDir
      into "${autoFvtDir}/build/classes"
    }

    // Copy the buildtask jars
    copy {
      from "${rootDir}/cnf/mavenlibs"
      into "${autoFvtDir}/build/lib"
      include 'asm-all-5.2.jar'
      include 'org.apache.aries.util-*.jar'
      include 'osgi.core*.jar'
      include 'jackson*.jar'
    }

    // Copy the com.ibm.ws.junit.extensions jar
    copy {
      from rootProject.project('com.ibm.ws.junit.extensions').buildDir
      include 'com.ibm.ws.junit.extensions.jar'
      into "${autoFvtDir}/build/lib"
    }
      
    // Copy the infra jar
    copy {
      from "${rootDir}/cnf/mavenlibs/infra.buildtasks-core-4.0.0.jar"
      into "${autoFvtDir}/build/lib"
    }

    // Copy the bundle jar
    copy {
      from buildDir
      include '*.jar'
      into "${autoFvtDir}/build/lib"
    }
    
    // Include JSON-P processor implementation
    copy {
      from rootProject.project('com.ibm.ws.org.glassfish.json').buildDir
      include '*.jar'
      into "${autoFvtDir}/lib"
    }

    // Copy the DDL files
    // TODO: Consider if this can be removed, it looks like there's only a single project for this rule
    copy {
      from "${projectDir}/ddl"
      include '**/*'
      into "${autoFvtDir}/ddl"
    }

    // Copy the autoFVT-defaults
    copy {
      from "${rootDir}/fattest.simplicity/autoFVT-defaults"
      include '**/*'
      into "${autoFvtDir}"
    }
    
    // Create a fat.bnd.properties file that contains metadata about the FAT
    def bndProps = new Properties()
    File propsFile = new File("${autoFvtDir}/fat.bnd.properties")
    // Check for minimum java level for test execution:
    def minJavaLevel = bnd('runtime.minimum.java.level')
    if(minJavaLevel == null)
      minJavaLevel = bnd('javac.source')
    bndProps.setProperty('runtime.minimum.java.level', minJavaLevel)
    // Check if we should override wlp classpath
    def wlpClasspath = bnd('test.classpath.wlp.include')
    if(wlpClasspath != null)
      bndProps.setProperty('test.classpath.wlp.include', wlpClasspath)
    
    def writer = new FileWriter(propsFile)
    try {
    	bndProps.store(writer, null)
    } finally {
      writer.close()
    }
    
    // Copy the component test libs
    // TODO: It looks like the componenttest.app.jar got combined into something else, so this is now way more source in the jar than was there before. This might need changing then.
    copy {
      from rootProject.project('com.ibm.ws.componenttest').buildDir
      include 'com.ibm.ws.componenttest.jar'
      rename 'com.ibm.ws.componenttest.jar', 'componenttest.app.jar'
      into "${autoFvtDir}/lib"
    }

    // Copy the fattest libs
    copy {
      from rootProject.project('fattest.simplicity').buildDir
      include 'fattest*.*'
      into "${autoFvtDir}/lib"
    }

    // TODO: This is to compensate for the fact that the ant build of fattest.simplicity produced this jar but the gradle build doesn't
    copy {
      from rootProject.project('com.ibm.ws.common.encoder').buildDir
      include 'com.ibm.ws.common.encoder.jar'
      rename 'com.ibm.ws.common.encoder.jar', 'fattest.encoder.jar'
      into "${autoFvtDir}/lib"
    }

    // Copy the published files
    copy {
      from "${projectDir}/publish/files", "${autoFvtDir}/publish/files"
      include '**/*'
      into "${autoFvtDir}/lib/LibertyFATTestFiles"
    }

    // Copy the publish directory (minus the 'files' directory)
    copy {
      from "${projectDir}/publish"
      include '**/*'
      exclude 'files'
      into "${autoFvtDir}/publish"
    }

    // Copy the logging libraries over for use while running FATs
    copy {
      from rootProject.project('com.ibm.ws.logging.core').buildDir
      include 'com.ibm.ws.logging.core.jar'
      into "${autoFvtDir}/lib"
    }
    
    // Copy all non-java app resourecs, such as *.html or *.jsp
    copy {
      includeEmptyDirs = false
      from "${projectDir}"
      into "${autoFvtDir}/"
      include 'test-applications/**', 'test-bundles/**', 'test-resourceadapters/**'
      exclude '**/*.java'
    }
    
    // Produce a list of features tested by this FAT
    def featureDeps = [] as Set
    // Include features added explictly via bnd.bnd
    def testedFeatures = bnd('tested.features')
    if(testedFeatures != null)
      testedFeatures.split(',').each{ featureDeps.add(it.trim().toLowerCase()) }
    // Scan publish/ dir for features
    if(file("${autoFvtDir}/publish/").exists()) {
      file("${autoFvtDir}/publish/").eachFileRecurse(groovy.io.FileType.FILES) {
        if(it.name.endsWith('.xml')) {
          file(it).eachLine { line ->
            if(line.contains("<feature>")) {
              def feature = (line =~ /.*<feature>(.*)<\/feature>.*/)[0][1]
              featureDeps.add(feature.trim().toLowerCase())
            }
          }
        }
      }
    }
    // Scan FAT files dir for features
    if(file("${autoFvtDir}/lib/LibertyFATTestFiles").exists()){
      file("${autoFvtDir}/lib/LibertyFATTestFiles").eachFileRecurse(groovy.io.FileType.FILES) {
        if(it.name.endsWith('.xml')) {
          file(it).eachLine { line ->
            if(line.contains("<feature>")) {
              def feature = (line =~ /.*<feature>(.*)<\/feature>.*/)[0][1]
              featureDeps.add(feature.trim().toLowerCase())
            }
          }
        }
      }
    }
    if(featureDeps.size() > 0) {
      println "This FAT tests the following features: " + featureDeps
      def fatDeps = new groovy.json.JsonBuilder()
      def root = fatDeps { 
    	  "feature-deps" featureDeps
      }
      new File("${autoFvtDir}/fat-metadata.json").write(new groovy.json.JsonBuilder(root).toPrettyString())
    } else {
      println "This FAT does not test any features."
    }
  }
}

task zipAutoFVT(type: Zip) {
  dependsOn autoFVT
  from "${buildDir}/autoFVT"
  into 'autoFVT'
  archiveName 'autoFVT.zip'
}

task zipProjectFVT(type: Zip) {
  dependsOn zipAutoFVT
  baseName project.name
  into project.name + '/build/lib', {from "${distsDir}/autoFVT.zip"}
  into project.name, {from 'build-test.xml'}
}

task runfat(type: Exec) {
  dependsOn cleanBeforeRun
  shouldRunAfter build
  shouldRunAfter cleanBeforeRun
  environment System.getProperties()
  if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
    executable "cmd"
    args '/c', 'ant', "-f", autoFvtDir + "/TestBuild.xml"
  } else {
    executable "ant"
    args "-f", autoFvtDir + "/TestBuild.xml"
  }
  doLast {
    // We can have this here because this task only ever runs locally, and thus is OK to unconditionally fail
    // the build. If we ever run FATs in remote builds, we should also gate this on a property like 
    // 'is.running.remote.build' so we don't fail the entire build whenever a testcase fails
    if(file(autoFvtDir + "/output/fail.log").exists())
      throw new GradleException("The FAT bucket has test failures! See the logs and results for details.")
  }
}

// Building a FAT is disabled by default, and enabled only when the gradle command contains "fat"
// For example './gradlew buildfat' (to build all FATs) or './gradlew build.example_fat:buildandrun'
def buildFatEnabled = false;
if(gradle.startParameter.getCurrentDir().getAbsolutePath().contains("_fat")) {
	buildFatEnabled = true;
} else {
	gradle.startParameter.taskNames.each {
		if(it.contains("fat")) {
			buildFatEnabled = true;
		}
	}
}

compileJava {
  dependsOn cleanFat
}

assemble {
  dependsOn zipProjectFVT
  // Skip out on 'assemble' unless top-level gradle invocation contains "fat"
  if(!buildFatEnabled) {
    enabled = false;
    dependsOn = [];
  }
}

build {
  // Skip out on 'build' unless top-level gradle invocation contains "fat"
  if(!buildFatEnabled) {
    enabled = false;
    dependsOn = [];
  }
}

buildfat {
  dependsOn build
}

task buildandrun {
  dependsOn buildfat
  dependsOn runfat
}
